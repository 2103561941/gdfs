# 文件目录树
### 备份方式：
1. 开启一个线程，将目录树结构定期写到磁盘里。 
2. 在 client 进行 put、mkdir 等操作后，将改操作记录到日志文件里，目录树在备份过程中丢失的结构可以通过日志文件来恢复。

定期读取目录树采用深搜或者广搜算法。存储格式暂定。
开启读目录树的时候，是将树的结构从内存中拷贝出来了一份，这样可以保证读到的树是某一时间段确定的树，而且不影响目录树正常使用。
在开启读目录树前，先创建一个新的日志文件，记录两次备份目录树之间的日志操作。
目录树创建好后删除旧的目录树文件和日志文件。

发送的情况分析：
1. namenode在备份的中间时间段挂了，使用当前最新的日志文件和上一个目录树文件进行重新生成树。
2. namenode在备份的时候挂了，此时使用旧的日志文件和新的日志文件，以及上一次生成的目录树结构。
3. 写日志文件的时候写入失败了，虽然这个情况很少见，但是也有可能发生，这时候可以采取多写几遍，

备份的目录树结构选取。
就采取一行一行写和一行一行读。
每个节点有固定的行数，分别表示某一类信息。
但是如果强制要求每一行内容的话，就可能导致信息全部错乱了，
这时候可以把在换个node写入的时候做一些换行之类的标识，如果该日志文件出现数量不对，根据文件前面的标识符来判断这是归类到node的哪个信息，缺少的信息就默认生成，提高日志文件的健壮性。
但是如果写入的顺序出错了，导致在node写入时找不到对应的文件，就直接fatal了。
还有一种情况是文件不是目录类型，但是却需要存children，这种也直接fatal。


node 写入格式：
要求严格按照深搜的方式写入，深搜的方式读取，这样可以减少search的时间，同时可以避免 读取 /path1/node 时 /path 还没有读到。
找到第一个非空行的位置,直到下一个非空行的位置是一个文件的信息。
1 FilePath   
2 FileName
3 FileType   存 1 代表目录， 2 代表普通文件    
4 FileSize   大小
5 FileKeys   每个filekey中间用空格隔开 
6 UpdateTime 字符串的形式保存或者in64类型保存，然后读取转化
7 CreateTime 与上面同理


日志文件结构选取。
一行一行写，一行一行读。
每行写入与目录树结构的写入内容与上面的要求一致。
如读取到 mkdir，在server层成功的时候，就要把相应的 node 信息写入到日志文件里去。
如果遇到的是rename，则要区别对待，日志文件里写入的就是旧的path 和 新的path。
delete 也是只需要写filepath 即可。
put 要求写全部信息。
其他get，list等就不需要写进日志里。


目录树备份

namenode重开，目录树读取，同时在cache中做一个create操作，create相应的filekey

